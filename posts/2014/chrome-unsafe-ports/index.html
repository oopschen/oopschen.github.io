<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    
    <meta name="description" content="石头的博客.">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:domain" content="http://oopschen.github.io">
    
    <meta name="twitter:image" content="http://oopschen.github.io/tn.png">
    <meta name="twitter:title" property="og:title" itemprop="title name" content="Oopschen的日志">
    <meta name="twitter:description" property="og:description" itemprop="description" content="石头的博客.">
    <meta name="og:type" content="website">
    <meta name="og:url" content="http://oopschen.github.io">
    <meta name="og:image" itemprop="image primaryImageOfPage" content="http://oopschen.github.io/tn.png">
    
    <title>Chrome Unsafe Port 浅析</title>
    <link rel="shortcut icon" href="http://oopschen.github.io/sam.ico" id="favicon">
    <link rel="stylesheet" href="http://oopschen.github.io/css/style.css">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">
    
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous"></script>
    
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-49453400-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'UA-49453400-1');
    </script>
    

</head>

</html>
<body><div class="wrap"><div class="section" id="title">Chrome Unsafe Port 浅析</div><div class="section" id="content">Sun Aug 10, 2014 &#183; 96 words

<div><span id="tag"><a href="http://oopschen.github.io/tags/chrome">chrome</a></span><span id="tag"><a href="http://oopschen.github.io/tags/err_unsafe_port">ERR_UNSAFE_PORT</a></span><span id="tag"><a href="http://oopschen.github.io/tags/port">port</a></span><span id="tag"><a href="http://oopschen.github.io/tags/security">security</a></span></div><hr/>

<p>最近一段时间在和docker愉快的玩耍, 但卡在一个非常奇怪的问题上面&ndash;新建了一个container, 基于centos6的image上安装了nginx一个app, 把host的6001端口映射到container的80端口, 把host的6000端口映射到6000端口.</p>

<h3 id="问题">问题</h3>

<p>开起这个container后, 在chrome中访问本地6001端口, 可以看到nginx的默认欢迎页面. 而访问6000端口则不能连接&ndash;是tcp无法建立连接的那种页面. 这就非常奇怪了.<br />
用命令查看</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">    docker port xxx <span style="color:#ae81ff">6000</span>  </code></pre></div>
<p>输出结果是绑定了本地的6000端口没有任何异议.可是为什么无法访问呢?</p>

<h3 id="思路">思路</h3>

<p>如此只能用nc工具查看端口是否开起:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">    nc -v localhost <span style="color:#ae81ff">6000</span>  </code></pre></div>
<p>端口是有输出的, 这就意味着端口是开启的. 接下来只能看是不是nginx的配置问题了, 当然在部署docker的时候nginx.conf文件是经过<strong>nginx -t</strong>检验的. 这时候就得用curl命令来检验了.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">    curl http://localhost:6000  </code></pre></div>
<p>由于nginx的配置了<em>autoIndex on</em>, 所以返回的页面中会有文件目录的内容. curl的结果是在预期内的, 也就是说docker的配置和nginx的配置是完全正确的.<br />
<strong>是什么引发了这个问题?</strong></p>

<h3 id="方案">方案</h3>

<p>由表面证据可以看到, 区别在chrome和curl. 为什么这两个agent会有什么区别? 好吧, 身为一个web开发者, 必须立马打开<strong>chrome://net-internals/#events</strong>页面查看打开6000页面的时候发生了什么问题. 结果是看到了<strong>ERR_UNSAFE_PORT</strong>错误, 而这个错误不会在错误页面出现, 当然console里也看不到. 迅速google了一下, 尼玛这确实是chrome干的好事情, 在<a href="http://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc?view=markup" title="Chrome unsafe port source code">Chromium的源代码</a>中确实内置这么一个功能&ndash;屏蔽一些已知的端口.<br />
<strong>这是为了什么呢?</strong></p>

<h3 id="反思">反思</h3>

<p>经过一系列的搜罗, 网上大致给出的解释是出于安全的考虑. 那到底会有怎么样的安全问题呢?(web开发者要有安全意识啊!!!)</p>

<h4 id="安全问题例子">安全问题例子</h4>

<p>假使我们有一个server listen在6000端口, 并接受request和response的模式, server也在防火墙后. 那么恶意攻击者可以怎么做才能伪造请求攻击server?(这里可以先思考几分钟, 看看有没有黑客的潜质!!!)
|<br />
|<br />
|<br />
|<br />
|<br />
|<br />
|<br />
|<br />
|<br />
|<br />
|<br />
好吧谜底揭晓:<br />
假如有一个pc和server在同一个内网, 恶意攻击者通过建立恶意网站利用javacript调用模拟发送请求到内网的server, 从而达到攻击的目的. 虽然要实施这个步骤需要很多条件, 但是确实是可行的, 因为chrome处于对自身安全的考虑, 建立了一个黑名单列表, 禁止访问这些端口, 这就是上面所述问题的原因.</p>

<h4 id="如何开放这个性质">如何开放这个性质</h4>

<p>chrome作为强大google的产品, 有入口当然会有出口, 既然默认是屏蔽的, 那么必须的可以解除这个屏蔽:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">    chorme --explicitly-allowed-ports<span style="color:#f92672">=</span>port1,port2,port3  </code></pre></div>
<h3 id="结论">结论</h3>

<p>虽然无意间踩到这个坑, 也学到了不少. 年轻的chrome在浏览器里是顶尖的. 当然我们web开发者在开发环境做端口选择的时候还是选一些10000以上的端口. 有兴趣的朋友还可以延伸阅读一下<a href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers" title="Well Known ports">这篇wiki</a>.</p>
</div><div class="section bottom-menu"><hr/><p>
<a href="/posts">back</a>
 &#183;



<a href="/posts">博客日志</a>


&#183; <a href="/about">我是谁?</a>

&#183; <a href="http://oopschen.github.io">home</a></p></div><div class="section footer">石头, OOPS!!!</div></div></body>