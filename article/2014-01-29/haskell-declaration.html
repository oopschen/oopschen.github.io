<!DOCTYPE html>
<html lang="zh_CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Focused on Tech">
    <meta name="author" content="Mr.C">
    <title>Mr.C Blog</title>
    <link  rel="stylesheet" href="/css/bootstrap.css" /><link  rel="stylesheet" href="/css/clean-blog.css" />

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49453400-1', 'oopschen.github.io');
  ga('send', 'pageview');
</script>
<script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fb92e3fa3521db5146fa7ee476d69fa7f' type='text/javascript'%3E%3C/script%3E"));</script>


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script defer="defer"  src="/lib/html5shiv.js"></script><script defer="defer"  src="/lib/respond.min.js"></script>
    <![endif]-->
</head>

<body>


<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://oopschen.github.io/index.html">Mr.C Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                  <li><a href="/index.html">Blog</a></li>
                
                  <li><a href="/about.html">Profile</a></li>
                
                  <li><a href="/archive.html">Archive</a></li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


<!-- Page Header -->
<!-- Set your background image for this header on the line below. -->
<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Haskell学习笔记--Declarations and Bindings</h1>
                    <h2 class="subheading">
                      [技术, haskell]
                      
                    </h2>
                    <span class="meta">
                        Updated on@January 29th 2014, 20:32
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>即将到年三十了, 好学的年轻人还是决定在今天花一个小时提升下自己的技能. 今天来看看Haskell 2010语言规范中的Declarations和Bindings.  </p>
<h1 id="declarations-">Declarations  </h1>
<p>这部分在理解Haskell中很重要, 因为他诠释了haskell这门语言是如何定义事情的, 他的定义会告诉编译器把这些代码生成低级机器语言.   </p>
<pre class="highlight"><code class="hljs haskell"><span class="hljs-module"><span class="hljs-keyword">module</span>    →    <span class="hljs-keyword">module</span> modid [exports] <span class="hljs-keyword">where</span></span> body
          |    body
<span class="hljs-title">body</span>    →    { impdecls ; topdecls }
          |    { impdecls }
          |    { topdecls }
<span class="hljs-title">topdecls</span>    →    topdecl1 ; … ; topdecln        (n ≥ <span class="hljs-number">1</span>)
<span class="hljs-title">topdecl</span>    →    <span class="hljs-typedef"><span class="hljs-keyword">type</span> simpletype = <span class="hljs-keyword">type</span></span>
          |    <span class="hljs-typedef"><span class="hljs-keyword">data</span> [context =&gt;] simpletype [= constrs] [<span class="hljs-keyword">deriving</span>]</span>
          |    <span class="hljs-typedef"><span class="hljs-keyword">newtype</span> [context =&gt;] simpletype = newconstr [<span class="hljs-keyword">deriving</span>]</span>
          |    <span class="hljs-keyword">class</span> [scontext =&gt;] tycls tyvar [<span class="hljs-keyword">where</span> cdecls]
          |    <span class="hljs-keyword">instance</span> [scontext =&gt;] qtycls inst [<span class="hljs-keyword">where</span> idecls]
          |    <span class="hljs-default"><span class="hljs-keyword">default</span> <span class="hljs-container">(<span class="hljs-title">type1</span> , … , <span class="hljs-title">typen</span>)</span>          <span class="hljs-container">(<span class="hljs-title">n</span> ≥ 0)</span></span>
          |    <span class="hljs-foreign"><span class="hljs-keyword">foreign</span> fdecl</span>
          |    decl
<span class="hljs-title">decls</span>    →    { decl1 ; … ; decln }        (n ≥ <span class="hljs-number">0</span>)
<span class="hljs-title">decl</span>    →    gendecl
          |    (funlhs | pat) rhs
<span class="hljs-title">cdecls</span>    →    { cdecl1 ; … ; cdecln }        (n ≥ <span class="hljs-number">0</span>)
<span class="hljs-title">cdecl</span>    →    gendecl
          |    (funlhs | var) rhs
<span class="hljs-title">idecls</span>    →    { idecl1 ; … ; idecln }        (n ≥ <span class="hljs-number">0</span>)
<span class="hljs-title">idecl</span>    →    (funlhs | var) rhs
          |            (empty)
<span class="hljs-title">gendecl</span>    →    vars :: [context =&gt;] <span class="hljs-typedef"><span class="hljs-keyword">type</span>        <span class="hljs-container">(<span class="hljs-title">type</span> <span class="hljs-title">signature</span>)</span></span>
          |    fixity [integer] ops        (fixity declaration)
          |            (empty declaration)
<span class="hljs-title">ops</span>    →    op1 , … , opn        (n ≥ <span class="hljs-number">1</span>)
<span class="hljs-title">vars</span>    →    var1 , … , varn        (n ≥ <span class="hljs-number">1</span>)
<span class="hljs-title">fixity</span>    →    <span class="hljs-infix"><span class="hljs-keyword">infixl</span> | <span class="hljs-keyword">infixr</span> | <span class="hljs-keyword">infix</span></span>
</code></pre><p>从上面我们可以看到有<em>topdecls</em>和<em>decls</em>的区分, topdecls只能在module的top level中被声明, 而不能在其他的scope(比如where, let等)中被声明. Haskell把Declarations分为三个组:  </p>
<ol>
<li>用户定义的, 包含type, newtype, data  </li>
<li>类型类和重载, 包含class, instance, default  </li>
<li>层级的声明, 包含value binding, type signatures和fixity  </li>
</ol>
<!-- more --> 
<p>我们来看下class <strong>Num</strong>在Prelude中的定义:</p>
<pre class="highlight"><code class="hljs autohotkey">class Num <span class="hljs-literal">a</span>  where          
<span class="hljs-label">    (+)    ::</span> <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span>  
<span class="hljs-label">    negate ::</span> <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span>
</code></pre><p>上面的代码不仅定义了他自己, 而且定义了他相关的操作的参数类型和返回类型. 当编译器遇到操作符<strong>+</strong>并且操作数为类型Num的时候, 他就会调用这里的<strong>(+)</strong>方法.  </p>
<p>再来看看<em>instance</em>的用法:  </p>
<pre class="highlight"><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Num</span> <span class="hljs-type">Int</span>  <span class="hljs-keyword">where</span></span>     
    x + y       =  addInt x y  
    negate x    =  negateInt x  
</code></pre><p>这段定义把Int定义为Num的实例, 让Int继承了Num的<em>(+)</em>和<em>negate</em>方法, 而where以后的定义是对两个方法的实现.  </p>
<h1 id="types-">Types  </h1>
<pre class="highlight"><code class="hljs oxygene"><span class="hljs-keyword">type</span>    →    btype [-&gt; <span class="hljs-keyword">type</span>]        (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">type</span>)
<span class="hljs-title">btype</span>    →    [<span class="hljs-title">btype</span>] <span class="hljs-title">atype</span>        <span class="hljs-params">(<span class="hljs-keyword">type</span> application)</span>
<span class="hljs-title">atype</span>    →    <span class="hljs-title">gtycon</span>
        |    <span class="hljs-title">tyvar</span>
        |    <span class="hljs-params">( type1 , … , typek )</span>        <span class="hljs-params">(<span class="hljs-keyword">tuple</span> <span class="hljs-keyword">type</span>, k ≥ 2)</span>
        |    [ <span class="hljs-title">type</span> ]        <span class="hljs-params">(list <span class="hljs-keyword">type</span>)</span>
        |    <span class="hljs-params">( <span class="hljs-keyword">type</span> )</span>        <span class="hljs-params">(parenthesised <span class="hljs-keyword">constructor</span>)</span>
<span class="hljs-title">gtycon</span>    →    <span class="hljs-title">qtycon</span>
        |    <span class="hljs-params">()</span>        <span class="hljs-params">(<span class="hljs-keyword">unit</span> <span class="hljs-keyword">type</span>)</span>
        |    []        <span class="hljs-params">(list <span class="hljs-keyword">constructor</span>)</span>
        |    <span class="hljs-params">(-&gt;)</span>        <span class="hljs-params">(<span class="hljs-keyword">function</span> <span class="hljs-keyword">constructor</span>)</span>
        |    <span class="hljs-params">(,{,})</span>        <span class="hljs-params">(tupling constructors)</span>
</span></code></pre><p>haskell的type系统是强类型, 并且是可以<strong>多态的</strong>. 注意这里指的是类型是多态的, 因为在其他编程语言中, 多态只限定在实例上. 这里我们先搞清楚两个东西:  </p>
<ol>
<li>type, 大写字母开头</li>
<li>type variable, 小写字母开头  </li>
</ol>
<p>所谓的type, 我们可以理解为对类型的定义, 比如以下代码  </p>
<pre class="highlight"><code class="hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">CustomizedType</span> = <span class="hljs-type">CustomizedTypeValueConstruct</span></span>
</code></pre><p>这里我们定义了一个类型<em>CustomizedType</em>, 这个类型有一个构造函数CustomizedTypeValueConstruct, 表明这个类型没有任何field.那么我们如何使用这个类型呢?  </p>
<pre class="highlight"><code class="hljs fix"><span class="hljs-attribute">va </span>=<span class="hljs-string"> CustomizedTypeValueConstruct 
</span></code></pre><p>如此我们就创建了一个type variable, 具有CustomizedType类型.  </p>
<p>我们再来看一个更加复杂的例子  </p>
<pre class="highlight"><code class="hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">People</span> = <span class="hljs-type">People</span> <span class="hljs-container">{
  <span class="hljs-title">name</span> :: [<span class="hljs-type">Char</span>],
  <span class="hljs-title">age</span> :: <span class="hljs-type">Int</span>
}</span></span>
<span class="hljs-title">me</span> = <span class="hljs-type">People</span> <span class="hljs-string">"Ray"</span> <span class="hljs-number">18</span>
<span class="hljs-title">anotherMe</span> = <span class="hljs-type">People</span> {
  name = <span class="hljs-string">"Ray"</span>,
  age = <span class="hljs-number">18</span>
}
</code></pre><p>上面我们定义了一个People类型, 他有一个叫做name和一个叫做age的fields. 咋看起来有点像c的struct.</p>
<h1 id="-">多态类型  </h1>
<p>看完上面的基础知识我们来回顾下面的代码:</p>
<pre class="highlight"><code class="hljs autohotkey"><span class="hljs-label">f ::</span> Num <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span>
</code></pre><p>这其中a是type variable, Num就是type. 那多态如何提现?  </p>
<pre class="highlight"><code class="hljs autohotkey"><span class="hljs-label">f ::</span> <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span>
</code></pre><p>如果f被定义为这样, 那么f可以接收任意类型, 并且返回接收的类型的类型值. 这就是类型多态的好处, 有点像c++中的template类的概念, 却比他强大很多.</p>
<h1 id="-">-&gt; 的定义  </h1>
<p>我们再来回顾下下面的代码:  </p>
<pre class="highlight"><code class="hljs autohotkey"><span class="hljs-label">f ::</span> <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span>
</code></pre><p>这段代码声明了f接受两个参数, 并返回同类型的参数. 那符号<em>-&gt;</em>会有多重意思么? 其实没有, haskell中-&gt;符号表示它左边的定义是函数的输入, 右侧的定义是函数的输出, 并不是我们所想的-&gt;是用来分割参数用的.  </p>
<p>上面的代码我们可以理解为  </p>
<pre class="highlight"><code class="hljs livecodeserver">f :: <span class="hljs-operator">a</span> - &gt; (<span class="hljs-operator">a</span> -&gt; <span class="hljs-operator">a</span>)
f <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- == (f 1) 1  </span>
</code></pre><p>也就是说当我们调用的时候, haskell会先调用<em>f 1</em>返回一个函数, 这个函数的类型是<em>a -&gt; a</em>, 然后再用1调用这个函数. 从而形成了类似一个函数接受多个参数的现象, 这也是haskell中比较怪异的一点, 他所有的函数只接受一个参数, 而多个参数调用的假象是利用上出原理造成的.  </p>
<h1 id="space-leak">space leak</h1>
<p>前几篇blog中我们提到过haskell的lazy解析, 就是说当haskell碰到1 + 1 这个表达式的时候, 他只记录下这个表达式, 当引用到这个表达式的值的时候, 我们才会真正计算这个表达式的值--2. space leak是指haskell中因为过多的记录表达式, 而导致系统内存耗尽. 看如下的例子  </p>
<pre class="highlight"><code class="hljs css"><span class="hljs-tag">sum</span> <span class="hljs-attr_selector">[1..100000000]</span>
</code></pre><p>在ghci中执行这个表达式, 足以让我的4g内存耗尽, 其实他做的事情很简单, 就是把1到100000000的数相加. 那为什么会耗尽内存呢?    </p>
<p>先来看下sum的源代码:  </p>
<pre class="highlight"><code class="hljs vbnet">sum l = sum<span class="hljs-comment">' l 0</span>
    <span class="hljs-keyword">where</span>
    sum<span class="hljs-comment">' []     a = a</span>
    sum<span class="hljs-comment">' (x:xs) a = sum' xs (a+x)</span>
</code></pre><p>从上米那我们不难看出, 当我们相加的数值越多, 生成的表达式<em>sum&#39; xs (a + x)</em>就越多, 也就消耗越多的内存, 最终导致内存耗尽.那如何避免呢?  </p>
<h1 id="seq-">seq  </h1>
<pre class="highlight"><code class="hljs lasso">seq <span class="hljs-tag">:: a</span> <span class="hljs-subst">-&gt; </span>b <span class="hljs-subst">-&gt; </span>b
</code></pre><p>他的功能就是将第一个表达式的值马上解析, 忽略lazy模式, 这样可以减少表达式的累积.  </p>
<p>我们可以把函数改写成  </p>
<pre class="highlight"><code class="hljs vbnet">sum l = sum<span class="hljs-comment">' 0 l</span>
    <span class="hljs-keyword">where</span>
    sum<span class="hljs-comment">' a [] = a</span>
    sum<span class="hljs-comment">' a (x:xs) = let   </span>
          val = a + x  
          <span class="hljs-keyword">in</span>  
          seq val (sum<span class="hljs-comment">' val xs)</span>
</code></pre><p>因为val表达式的值不会累积, 所以内存消耗是个常量.  </p>
<p>其实关于这样的设计, 也说不上好坏, 只能说有很多坑, 对于不了解haskell编译器实现的人来说,  这些简直就是噩梦.  </p>
<h1 id="-">(.) 函数  </h1>
<p>再介绍一个比较有趣的函数--<em>.</em>  </p>
<pre class="highlight"><code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-params">(.)</span> :: <span class="hljs-params">(b -&gt; c)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(a -&gt; b)</span> -&gt;</span> a<span class="hljs-function"> -&gt;</span> c
</code></pre><p>这个定义看起来似乎很复杂, 那我们拆解来看:</p>
<ol>
<li>接收<em>b -&gt; c</em>类型的参数, 返回 (a -&gt; b) -&gt; a -&gt; c 类型的值  </li>
<li>接收<em>a -&gt; b</em>类型的参数, 返回a-&gt;c类型的值  </li>
<li>接收<em>a</em>类型的参数, 返回c类型的值  </li>
</ol>
<p>我们来看个例子:  </p>
<pre class="highlight"><code class="hljs livecodeserver"><span class="hljs-built_in">length</span> . <span class="hljs-keyword">words</span> <span class="hljs-string">"hello world"</span> <span class="hljs-comment">-- output 2</span>
</code></pre><p>以下是length和words函数的定义:</p>
<pre class="highlight"><code class="hljs livecodeserver"><span class="hljs-built_in">length</span> :: [<span class="hljs-operator">a</span>] -&gt; Int
<span class="hljs-keyword">words</span> :: String -&gt; [String]
</code></pre><p>我们拿出纸笔来模拟haskell执行的过程:  </p>
<ol>
<li>b -&gt; c, 就是length函数, b为[a]--一个类型为a的数组, c为Int类型  </li>
<li>a -&gt; b, 则是words函数, a为String类型, b为类型为String的数组, 也就是说1中的a类型为String  </li>
</ol>
<p>所以这个表达式的返回值是2.通过这个例子我们不难发现其实<em>(.)</em>函数就是我们熟悉的管道, 让一个函数的返回值作为另一个函数的输入.  </p>
<h1 id="-">部分函数  </h1>
<p>这里我们来看一段更有意思的代码</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-tag">map</span> (3 + ) <span class="hljs-attr_selector">[1,2]</span> <span class="hljs-tag">--</span> <span class="hljs-tag">output</span> <span class="hljs-attr_selector">[4, 5]</span>
</code></pre><p>map顾名思义就是将每个list中的值当作函数的参数调用, 并返回一个list. 这段代码最离奇的是<em>(3 + )</em>这部分, 似乎是一个不完整的表达式, 难道就不会报错么?  </p>
<p>其实这个表达式在haskell中称为partial function, 我只能把他翻译成部分函数了, 它就是一个函数, 它右边的参数被认为<em>+</em>的右侧操作符.</p>



              <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a><a href="#" class="bds_qq" data-cmd="qq" title="分享到QQ收藏"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{},"image":{"viewList":["qzone","tsina","renren","weixin","tieba","douban","qq"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","renren","weixin","tieba","douban","qq"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

              <hr>

              <script type="text/javascript"> var disqus_shortname = 'sangeshitou'; (function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script>


            </div>
        </div>
    </div>
</article>

<hr>
  </body>

  <script defer="defer"  src="/lib/jquery.min.js"></script><script defer="defer"  src="/lib/bootstrap.min.js"></script><script defer="defer"  src="/lib/clean-blog.min.js"></script>

  <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
</html>

