---
title: C 中整型相等判断效率 
tags:
    - c
    - performance 
date: '2013-06-21 10:43:54'
draft: false
alias:
    - article/2013-06-21/c-integer-efficiency.html
categories:
    - TECH 
---
在类型明确的编程语言中,都存在整型类型,这也是计算机的基本类型之一,同时计算速度最快的类型。而在编码的过程中,对整型是否相等的计算也时常能碰到。然而,每个人的写法却不尽相同,本博客就对常见的两种写法进行效率比较。  
  
#### 测试平台  
1. OS: gentoo x86_64 in vmware 9
2. compiler: clang 3.2
  
#### 测试代码  

##### 使用bit操作进行判断, 简称A
```c
    int main() {
      int a = 1;
      if (!(1 ^ a)) {
        return 0;
      }
      return 1;
    }
```

##### 使用==操作进行判断, 简称B
```c
    int main() {
      int a = 1;
      if (1 == a) {
        return 0;
      }
      return 1;
    }
```
  
#### 判断标准  
由于个平台的差异,所以我们以指令书为效率的判断标准
  
#### 实验结果  
下面的结果排除的相同的地方,只摘取了条件判断不同的地方
##### A 的汇编结果  

    movl	-8(%rsp), %eax
    xorl	$1, %eax
    cmpl	$0, %eax

##### B 的汇编结果  

    cmpl	-8(%rsp), %eax
      
由上面的结果可以看出其实B的方案执行的效率更高一些。  
  
然而结果真的是这么？下面我们在编译的选项上加入优化。  
执行如下命令  
```Bash
    clang -O2 xxx.c -S
```
  
##### 实验结果  
两个文件的编译结果完全相同,而条件判断部分的汇编结果为：  

    xorl	%eax, %eax
      
#### 结论  
一般来说位操作肯定比==操作快,但是编译器在不加优化的情况下,生成了一个临时变量,所以多执行了2个指令,这是因为默认情况下,编译器偏向使用更容易debug和更快编译的方式编译代码。
